#!/bin/bash

# Asana Daily Summary Script for Ideon Scraping Internal
# Generates a summary of last 24 hours activity

set -e

# Options (defaults)
POST_PROCESS=false
POST_CLICKUP=false

# Parse arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    --process|-p)
      POST_PROCESS=true
      shift
      ;;
    --clickup|-c)
      POST_CLICKUP=true
      shift
      ;;
    --all|-a)
      POST_PROCESS=true
      POST_CLICKUP=true
      shift
      ;;
    --help|-h)
      echo "Usage: $0 [OPTIONS]"
      echo ""
      echo "Options:"
      echo "  -p, --process   Post-process with Claude (clean markdown)"
      echo "  -c, --clickup   Post to ClickUp #Scraping channel"
      echo "  -a, --all       Enable all options (process + clickup)"
      echo "  -h, --help      Show this help"
      echo ""
      echo "Examples:"
      echo "  $0              # Raw report only"
      echo "  $0 -p           # Raw + Claude post-processing"
      echo "  $0 -c           # Raw + post to ClickUp"
      echo "  $0 -a           # Raw + process + ClickUp"
      exit 0
      ;;
    *)
      echo "Unknown option: $1"
      echo "Use --help for usage"
      exit 1
      ;;
  esac
done

# Load environment
source ~/.claude/.env 2>/dev/null || true

# Configuration
PROJECT_GID="1208639428824137"
WORKSPACE_GID="1200807498271803"
API_BASE="https://app.asana.com/api/1.0"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
OUTPUT_DIR="${SCRIPT_DIR}/asana_daily_summary"

# Date calculations
TODAY=$(date -u +"%Y-%m-%d")
SINCE=$(date -v-24H -u +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || date -d "24 hours ago" -u +"%Y-%m-%dT%H:%M:%SZ")

# Sections to exclude from overdue tracking
EXCLUDED_SECTIONS="Submitted|Internal Approved|Approved|Hold/Cancelled|To do"

# Temp files
TMP_DIR="/tmp/asana_summary_$$"
mkdir -p "$TMP_DIR"
mkdir -p "$OUTPUT_DIR"

cleanup() {
  rm -rf "$TMP_DIR"
}
trap cleanup EXIT

# Function to generate raw report
generate_raw_report() {
echo "ğŸ“Š Ideon Scraping Internal - Daily Summary - Generated By Claude Code"
echo "   Generated: $(date '+%b %d, %Y %H:%M:%S')"
echo "   Period: Last 24 hours"
echo ""
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

# Get recently modified tasks
MODIFIED_TASKS=$(curl -s "${API_BASE}/workspaces/${WORKSPACE_GID}/tasks/search?projects.any=${PROJECT_GID}&modified_at.after=${SINCE}&opt_fields=gid,name,assignee.name,completed,modified_at,memberships.section.name&limit=100" \
  -H "Authorization: Bearer $ASANA_ACCESS_TOKEN")

TASK_GIDS=$(echo "$MODIFIED_TASKS" | jq -r '.data[].gid')

# Process each task's stories
for task_gid in $TASK_GIDS; do
  TASK_NAME=$(echo "$MODIFIED_TASKS" | jq -r --arg gid "$task_gid" '.data[] | select(.gid == $gid) | .name')

  STORIES=$(curl -s "${API_BASE}/tasks/${task_gid}/stories?opt_fields=created_at,created_by.name,resource_subtype,text" \
    -H "Authorization: Bearer $ASANA_ACCESS_TOKEN")

  # Filter and process stories from last 24 hours
  echo "$STORIES" | jq -r --arg since "$SINCE" --arg task "$TASK_NAME" '
    .data[] | select(.created_at > $since) |
    "\(.resource_subtype)|\($task)|\(.created_by.name // "System")|\(.text)"
  ' >> "$TMP_DIR/all_stories.txt" 2>/dev/null || true
done

# Categorize stories
if [ -f "$TMP_DIR/all_stories.txt" ]; then
  # Completed/Approved
  grep "section_changed" "$TMP_DIR/all_stories.txt" 2>/dev/null | \
    grep -E 'to "(Internal Approved|Submitted|Approved)"' | \
    sort -u > "$TMP_DIR/completed.txt" 2>/dev/null || true

  # Issues Found
  grep "section_changed" "$TMP_DIR/all_stories.txt" 2>/dev/null | \
    grep -E 'to "(Scrape Error|QA Error)"' | \
    sort -u > "$TMP_DIR/issues.txt" 2>/dev/null || true

  # Fixes (moved back from error states)
  grep "section_changed" "$TMP_DIR/all_stories.txt" 2>/dev/null | \
    grep -E 'from "(Scrape Error|QA Error|QA Fixes)".*to "(Scraping|QA Fixes|Internal Approved)"' | \
    sort -u > "$TMP_DIR/fixes.txt" 2>/dev/null || true

  # Progressing (forward movement, excluding already categorized)
  grep "section_changed" "$TMP_DIR/all_stories.txt" 2>/dev/null | \
    grep -E 'to "(Coding|Scraping|QA|QA Check)"' | \
    grep -vE 'to "(Scrape Error|QA Error)"' | \
    sort -u > "$TMP_DIR/progress.txt" 2>/dev/null || true

  # User actions count (only valid usernames, exclude comments/URLs)
  cut -d'|' -f3 "$TMP_DIR/all_stories.txt" 2>/dev/null | \
    grep -v "System" | grep -v "null" | grep -v "^$" | \
    grep -vE "^(http|https|First|Last|Have|Approving|[0-9])" | \
    grep -E "^[A-Z][a-z]+ [A-Z][a-z]+" | \
    sort | uniq -c | sort -rn > "$TMP_DIR/user_actions.txt" 2>/dev/null || true
fi

# Display Completed/Approved
echo ""
echo "âœ… COMPLETED/APPROVED"
if [ -s "$TMP_DIR/completed.txt" ]; then
  while IFS='|' read -r type task user text; do
    section=$(echo "$text" | grep -oE 'to "[^"]+"' | head -1 | sed 's/to "//;s/"//')
    echo "   â€¢ ${task} â†’ ${section} (${user})"
  done < "$TMP_DIR/completed.txt" | sort -u
else
  echo "   (none)"
fi

# Display Progressing
echo ""
echo "ğŸ”„ PROGRESSING"
if [ -s "$TMP_DIR/progress.txt" ]; then
  while IFS='|' read -r type task user text; do
    section=$(echo "$text" | grep -oE 'to "[^"]+"' | head -1 | sed 's/to "//;s/"//')
    echo "   â€¢ ${task} â†’ ${section} (${user})"
  done < "$TMP_DIR/progress.txt" | sort -u
else
  echo "   (none)"
fi

# Display Issues Found
echo ""
echo "âš ï¸  ISSUES FOUND"
if [ -s "$TMP_DIR/issues.txt" ]; then
  while IFS='|' read -r type task user text; do
    section=$(echo "$text" | grep -oE 'to "[^"]+"' | head -1 | sed 's/to "//;s/"//')
    echo "   â€¢ ${task} â†’ ${section} (${user})"
  done < "$TMP_DIR/issues.txt" | sort -u
else
  echo "   (none)"
fi

# Display Fixes In Progress
echo ""
echo "ğŸ”§ FIXES IN PROGRESS"
if [ -s "$TMP_DIR/fixes.txt" ]; then
  while IFS='|' read -r type task user text; do
    to_section=$(echo "$text" | grep -oE 'to "[^"]+"' | head -1 | sed 's/to "//;s/"//')
    echo "   â€¢ ${task} â†’ ${to_section} (${user})"
  done < "$TMP_DIR/fixes.txt" | sort -u
else
  echo "   (none)"
fi

echo ""
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

# Get overdue tasks (excluding Submitted/Approved sections)
echo ""
echo "ğŸš¨ OVERDUE TASKS"
curl -s "${API_BASE}/projects/${PROJECT_GID}/tasks?opt_fields=gid,name,assignee.name,due_on,completed,memberships.section.name&limit=100" \
  -H "Authorization: Bearer $ASANA_ACCESS_TOKEN" | \
  jq -r --arg today "$TODAY" '
    .data[] |
    select(.completed == false and .due_on != null and .due_on < $today) |
    select(.memberships[0].section.name | test("Submitted|Internal Approved|Approved|Hold|To do") | not) |
    {
      name,
      assignee: (.assignee.name // "âš ï¸ Unassigned"),
      due_on,
      section: .memberships[0].section.name
    } |
"   â€¢ \(.name) (\(.section)) - due \(.due_on) â†’ \(.assignee)"
  ' | while read -r line; do
    # Calculate days overdue
    task_due=$(echo "$line" | grep -oE 'due [0-9]{4}-[0-9]{2}-[0-9]{2}' | sed 's/due //')
    if [ -n "$task_due" ]; then
      days=$(( ($(date -jf "%Y-%m-%d" "$TODAY" +%s 2>/dev/null || date -d "$TODAY" +%s) - $(date -jf "%Y-%m-%d" "$task_due" +%s 2>/dev/null || date -d "$task_due" +%s)) / 86400 ))
      echo "$line" | sed "s/due $task_due/$days days overdue/"
    else
      echo "$line"
    fi
  done | sort -t'-' -k2 -rn

echo ""
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

# Get workload distribution
echo ""
echo "ğŸ“‹ WORKLOAD DISTRIBUTION (Active Tasks)"
echo ""
printf "   %-20s â”‚ %5s â”‚ %s\n" "Assignee" "Tasks" "Breakdown"
echo "   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"

curl -s "${API_BASE}/projects/${PROJECT_GID}/tasks?opt_fields=gid,name,assignee.name,completed,memberships.section.name&limit=100" \
  -H "Authorization: Bearer $ASANA_ACCESS_TOKEN" | \
  jq -r '
    [.data[] | select(.completed == false) | select(.memberships[0].section.name | test("To do|Hold|Approved$") | not)] |
    group_by(.assignee.name // "âš ï¸ Unassigned") |
    map({
      assignee: (.[0].assignee.name // "âš ï¸ Unassigned"),
      count: length,
      breakdown: (group_by(.memberships[0].section.name) | map("\(length) \(.[0].memberships[0].section.name)") | join(", "))
    }) |
    sort_by(.count) | reverse |
    .[] |
    "   \(.assignee)|\(.count)|\(.breakdown)"
  ' | while IFS='|' read -r assignee count breakdown; do
    printf "%-23s â”‚ %5s â”‚ %s\n" "$assignee" "$count" "$breakdown"
  done

echo ""
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

# User activity count
echo ""
echo "ğŸ‘¥ USER ACTIVITY (Last 24h)"
if [ -s "$TMP_DIR/user_actions.txt" ]; then
  while read -r count user; do
    printf "   %-20s %3d actions\n" "$user" "$count"
  done < "$TMP_DIR/user_actions.txt"
else
  echo "   (no activity recorded)"
fi

echo ""
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
}

# Generate raw report and save to temp file
generate_raw_report > "$TMP_DIR/raw_output.txt" 2>&1

# Show raw output
cat "$TMP_DIR/raw_output.txt"

# Save raw output to file
OUTPUT_FILE="${OUTPUT_DIR}/${TODAY}.md"
cp "$TMP_DIR/raw_output.txt" "$OUTPUT_FILE"
echo ""
echo "âœ… Saved to: $OUTPUT_FILE"

# Post-process with Claude (optional)
if [ "$POST_PROCESS" = true ]; then
  echo ""
  echo "ğŸ¤– Post-processing with Claude..."
  echo ""

  claude -p "Clean up this Asana daily report by deduplicating entries.

Rules:
1. Remove duplicate entries - if same task appears multiple times, keep only the final/most significant state
2. If a task went through multiple stages today, show only the final state reached
3. Do NOT convert to tables
4. Output ONLY the cleaned report - no explanations, no 'Changes made', no commentary, no preamble
5. Add a summary of the report at the end with key actions and insights.

Raw report:

$(cat "$TMP_DIR/raw_output.txt")" --output-format text > "$OUTPUT_FILE"

  echo "âœ… Processed summary saved to: $OUTPUT_FILE"
  echo ""
  cat "$OUTPUT_FILE"
fi

# Post to ClickUp (optional)
if [ "$POST_CLICKUP" = true ]; then
  CLICKUP_WORKSPACE_ID="9017490901"
  CLICKUP_CHANNEL_ID="8cqqzen-1397"

  echo ""
  echo "ğŸ“¤ Posting to ClickUp #Scraping channel..."
  echo ""

  CLICKUP_MESSAGE=$(cat "$OUTPUT_FILE")

  CLICKUP_RESPONSE=$(curl -s -X POST "https://api.clickup.com/api/v3/workspaces/${CLICKUP_WORKSPACE_ID}/chat/channels/${CLICKUP_CHANNEL_ID}/messages" \
    -H "Authorization: $CLICKUP_API_TOKEN" \
    -H "Content-Type: application/json" \
    -d "$(jq -n --arg content "$CLICKUP_MESSAGE" '{"content": $content}')")

  if echo "$CLICKUP_RESPONSE" | jq -e '.id' > /dev/null 2>&1; then
    echo "âœ… Posted to ClickUp #Scraping channel successfully!"
  else
    echo "âŒ Failed to post to ClickUp:"
    echo "$CLICKUP_RESPONSE" | jq
  fi
fi
